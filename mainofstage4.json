import json
import argparse
import sys
import urllib.request
import urllib.error
import subprocess
import tempfile
import os
from collections import deque, defaultdict
from typing import Dict, Any, List, Set, Tuple
from urllib.parse import urlparse


class ConfigError(Exception):
    pass


class DependencyFetchError(Exception):
    pass


class DependencyVisualizer:
    def __init__(self, config_path: str):
        self.config = self._load_config(config_path)
        self._validate_config()
        self.dependency_graph = {}
        self.load_order = []
        self.npm_load_order = []

    def _load_config(self, config_path: str) -> Dict[str, Any]:
        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            raise ConfigError(f"Config file not found: {config_path}")
        except json.JSONDecodeError as e:
            raise ConfigError(f"Invalid JSON in config file: {e}")

    def _validate_config(self):
        required_fields = [
            'package_name',
            'repo_url',
            'test_repo_mode',
            'output_image',
            'ascii_tree',
            'show_load_order'
        ]

        for field in required_fields:
            if field not in self.config:
                raise ConfigError(f"Missing required field: {field}")

        if not isinstance(self.config['package_name'], str):
            raise ConfigError("package_name must be a string")

        if not isinstance(self.config['repo_url'], str):
            raise ConfigError("repo_url must be a string")

        if not isinstance(self.config['test_repo_mode'], bool):
            raise ConfigError("test_repo_mode must be a boolean")

        if not isinstance(self.config['output_image'], str):
            raise ConfigError("output_image must be a string")

        if not isinstance(self.config['ascii_tree'], bool):
            raise ConfigError("ascii_tree must be a boolean")

        if not isinstance(self.config['show_load_order'], bool):
            raise ConfigError("show_load_order must be a boolean")

        if self.config['test_repo_mode']:
            if 'test_repo_path' not in self.config:
                raise ConfigError("test_repo_path is required in test mode")
            if not isinstance(self.config['test_repo_path'], str):
                raise ConfigError("test_repo_path must be a string")

    def print_config(self):
        print("Configuration parameters:")
        for key, value in self.config.items():
            print(f"  {key}: {value}")

    def load_test_repository(self):
        """Загружает тестовый репозиторий из файла"""
        try:
            with open(self.config['test_repo_path'], 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            raise DependencyFetchError(f"Test repository file not found: {self.config['test_repo_path']}")
        except json.JSONDecodeError as e:
            raise DependencyFetchError(f"Invalid JSON in test repository: {e}")

    def fetch_npm_dependencies(self, package_name: str) -> List[str]:
        """Получает зависимости пакета из npm registry"""
        try:
            package_url = f"https://registry.npmjs.org/{package_name}"
            with urllib.request.urlopen(package_url) as response:
                data = json.loads(response.read().decode())

            latest_version = data.get('dist-tags', {}).get('latest')
            if not latest_version:
                return []

            version_data = data.get('versions', {}).get(latest_version, {})
            dependencies = version_data.get('dependencies', {})

            return list(dependencies.keys())

        except Exception as e:
            print(f"Warning: Could not fetch dependencies for {package_name}: {e}")
            return []

    def build_dependency_graph_bfs(self):
        """Строит граф зависимостей с помощью BFS"""
        print(f"\nBuilding dependency graph for package: {self.config['package_name']}")

        if self.config['test_repo_mode']:
            test_repo = self.load_test_repository()
            root_package = self.config['package_name']

            if root_package not in test_repo:
                raise DependencyFetchError(f"Package {root_package} not found in test repository")

            queue = deque([root_package])
            visited = set()

            while queue:
                current_package = queue.popleft()
                if current_package in visited:
                    continue

                visited.add(current_package)
                dependencies = test_repo.get(current_package, [])
                self.dependency_graph[current_package] = dependencies

                for dep in dependencies:
                    if dep not in visited:
                        queue.append(dep)
        else:
            root_package = self.config['package_name']
            queue = deque([root_package])
            visited = set()

            while queue:
                current_package = queue.popleft()
                if current_package in visited:
                    continue

                visited.add(current_package)
                dependencies = self.fetch_npm_dependencies(current_package)
                self.dependency_graph[current_package] = dependencies

                for dep in dependencies:
                    if dep not in visited:
                        queue.append(dep)

    def calculate_load_order(self):
        """Вычисляет порядок загрузки зависимостей с помощью топологической сортировки"""
        print("\nCalculating dependency load order...")

        # Строим обратный граф для вычисления входящих степеней
        in_degree = defaultdict(int)
        reverse_graph = defaultdict(list)

        for package, dependencies in self.dependency_graph.items():
            for dep in dependencies:
                reverse_graph[dep].append(package)
                in_degree[package] += 1

        # Инициализируем очередь пакетами с нулевой входящей степенью
        queue = deque([pkg for pkg in self.dependency_graph if in_degree[pkg] == 0])
        load_order = []

        while queue:
            current = queue.popleft()
            load_order.append(current)

            for dependent in reverse_graph[current]:
                in_degree[dependent] -= 1
                if in_degree[dependent] == 0:
                    queue.append(dependent)

        # Проверяем, все ли пакеты были обработаны (отсутствие циклов)
        if len(load_order) != len(self.dependency_graph):
            print("Warning: Graph contains cycles, load order may be incomplete")

        self.load_order = load_order

    def get_npm_load_order(self) -> List[str]:
        """Получает реальный порядок загрузки зависимостей через npm"""
        print("\nGetting real npm load order...")

        try:
            # Создаем временный package.json для тестирования
            with tempfile.TemporaryDirectory() as temp_dir:
                package_json = {
                    "name": "test-package",
                    "version": "1.0.0",
                    "dependencies": {
                        self.config['package_name']: "latest"
                    }
                }

                package_json_path = os.path.join(temp_dir, "package.json")
                with open(package_json_path, 'w') as f:
                    json.dump(package_json, f)

                # Запускаем npm install и получаем вывод
                result = subprocess.run(
                    ["npm", "install"],
                    cwd=temp_dir,
                    capture_output=True,
                    text=True,
                    timeout=120  # 2 минуты таймаут
                )

                if result.returncode != 0:
                    print(f"npm install failed: {result.stderr}")
                    return []

                # Получаем дерево зависимостей
                tree_result = subprocess.run(
                    ["npm", "ls", "--all", "--parseable"],
                    cwd=temp_dir,
                    capture_output=True,
                    text=True
                )

                if tree_result.returncode == 0:
                    # Парсим вывод npm ls для получения порядка
                    paths = tree_result.stdout.strip().split('\n')
                    packages = []
                    for path in paths:
                        if 'node_modules' in path:
                            pkg_name = path.split('node_modules')[-1].lstrip('/').split('/')[-1]
                            if pkg_name and pkg_name not in packages:
                                packages.append(pkg_name)

                    return packages
                else:
                    print(f"npm ls failed: {tree_result.stderr}")
                    return []

        except subprocess.TimeoutExpired:
            print("npm install timed out")
            return []
        except Exception as e:
            print(f"Error getting npm load order: {e}")
            return []

    def compare_load_orders(self):
        """Сравнивает наш порядок загрузки с реальным npm порядком"""
        print("\n" + "=" * 50)
        print("LOAD ORDER COMPARISON")
        print("=" * 50)

        print(f"\nOur load order ({len(self.load_order)} packages):")
        for i, package in enumerate(self.load_order, 1):
            print(f"  {i:2d}. {package}")

        print(f"\npm load order ({len(self.npm_load_order)} packages):")
        for i, package in enumerate(self.npm_load_order, 1):
            print(f"  {i:2d}. {package}")

        # Анализ различий
        our_set = set(self.load_order)
        npm_set = set(self.npm_load_order)

        only_in_our = our_set - npm_set
        only_in_npm = npm_set - our_set
        common = our_set & npm_set

        print(f"\nCOMPARISON ANALYSIS:")
        print(f"  Common packages: {len(common)}")
        print(f"  Only in our order: {len(only_in_our)}")
        print(f"  Only in npm order: {len(only_in_npm)}")

        if only_in_our:
            print(f"  Packages only in our order: {sorted(only_in_our)}")

        if only_in_npm:
            print(f"  Packages only in npm order: {sorted(only_in_npm)}")

        # Анализ позиционных различий для общих пакетов
        positional_diffs = []
        for pkg in common:
            our_pos = self.load_order.index(pkg) + 1
            npm_pos = self.npm_load_order.index(pkg) + 1
            if our_pos != npm_pos:
                positional_diffs.append((pkg, our_pos, npm_pos, abs(our_pos - npm_pos)))

        if positional_diffs:
            print(f"\nPOSITIONAL DIFFERENCES (sorted by difference magnitude):")
            positional_diffs.sort(key=lambda x: x[3], reverse=True)
            for pkg, our_pos, npm_pos, diff in positional_diffs[:10]:  # Показываем топ-10 различий
                print(f"  {pkg}: our position {our_pos}, npm position {npm_pos} (diff: {diff})")

    def print_load_order(self):
        """Выводит порядок загрузки зависимостей"""
        if not self.load_order:
            print("No load order calculated")
            return

        print(f"\nOur dependency load order for '{self.config['package_name']}':")
        for i, package in enumerate(self.load_order, 1):
            print(f"  {i:2d}. {package}")

    def demonstrate_comparison(self):
        """Демонстрирует сравнение на тестовом репозитории"""
        if not self.config['test_repo_mode']:
            return

        print("\n" + "=" * 50)
        print("TEST REPOSITORY DEMONSTRATION")
        print("=" * 50)

        test_repo = self.load_test_repository()

        # Демонстрация различных случаев
        test_cases = [
            ("Simple linear dependency", {"A": ["B"], "B": ["C"], "C": []}),
            ("Diamond dependency", {"A": ["B", "C"], "B": ["D"], "C": ["D"], "D": []}),
            ("Cyclic dependency", {"A": ["B"], "B": ["C"], "C": ["A"]}),
        ]

        for case_name, graph in test_cases:
            print(f"\n{case_name}:")
            print(f"  Graph: {graph}")

            # Временно подменяем граф для демонстрации
            original_graph = self.dependency_graph.copy()
            self.dependency_graph = graph

            # Вычисляем порядок загрузки
            self.calculate_load_order()
            print(f"  Our load order: {self.load_order}")

            # Восстанавливаем оригинальный граф
            self.dependency_graph = original_graph


def main():
    parser = argparse.ArgumentParser(description='Dependency Graph Visualizer - Stage 4: Additional Operations')
    parser.add_argument('--config', default='config4.json', help='Path to config file (default: config4.json)')
    args = parser.parse_args()

    try:
        visualizer = DependencyVisualizer(args.config)
        visualizer.print_config()

        # Построение графа зависимостей
        visualizer.build_dependency_graph_bfs()

        # Вычисление и вывод порядка загрузки
        if visualizer.config['show_load_order']:
            visualizer.calculate_load_order()
            visualizer.print_load_order()

            # Получение реального порядка загрузки npm
            visualizer.npm_load_order = visualizer.get_npm_load_order()

            # Сравнение порядков загрузки
            if visualizer.npm_load_order:
                visualizer.compare_load_orders()

            # Демонстрация на тестовом репозитории
            if visualizer.config['test_repo_mode']:
                visualizer.demonstrate_comparison()

        print("\nStage 4 completed successfully!")

    except ConfigError as e:
        print(f"Configuration error: {e}", file=sys.stderr)
        sys.exit(1)
    except DependencyFetchError as e:
        print(f"Dependency fetch error: {e}", file=sys.stderr)
        sys.exit(2)
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        sys.exit(3)


if __name__ == '__main__':
    main()
